/*
 * generated by Xtext 2.24.0
 */
package org.big.erd.validation

import org.big.erd.entityRelationship.Model
import org.eclipse.xtext.validation.Check
import org.big.erd.entityRelationship.CardinalityType
import org.big.erd.entityRelationship.RelationEntity
import org.big.erd.entityRelationship.NotationType
import org.eclipse.xtext.validation.ComposedChecks
import org.big.erd.entityRelationship.Entity
import org.big.erd.entityRelationship.AttributeType
import static org.big.erd.entityRelationship.EntityRelationshipPackage.Literals.*
import org.big.erd.entityRelationship.Relationship
import org.big.erd.entityRelationship.RelationshipType
import org.big.erd.entityRelationship.VisibilityType
import org.big.erd.entityRelationship.Attribute

/**
 * Custom ValidationRules with composed checks 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation for documentation
 */
@ComposedChecks(validators=#[
	NamingValidator
])
class EntityRelationshipValidator extends AbstractEntityRelationshipValidator {

	public static final String UNSUPPORTED_NOTATION = "unsupportedNotation";
	public static final String MISSING_PRIMARY_KEY = "missingPrimaryKey";
	public static final String MISSING_PARTIAL_KEY = "missingPartialKey";
	public static final String INVALID_CARDINALITY = "invalidCardinality";
	
	@Check
	def checkKeys(Entity entity) {
		if (entity.weak) {
			if (entity.attributes?.filter[it.type === AttributeType.PARTIAL_KEY].isNullOrEmpty) {
				warning('''Missing partial key for weak entity''', entity, ENTITY__ATTRIBUTES, MISSING_PARTIAL_KEY)
			}
		} else {
			if (entity.attributes?.filter[it.type === AttributeType.KEY].isNullOrEmpty) {
				warning('''Missing primary key for entity''', entity, ENTITY__ATTRIBUTES, MISSING_PRIMARY_KEY)
			}
		}
	}
	
	@Check
	def checkRelationEntity(RelationEntity relation) {
		val model = relation.eContainer.eContainer
		if (model instanceof Model) {
			val notation = model.notation?.notationType
			if (notation !== null) {
				if (notation.equals(NotationType.BACHMAN) ||
					notation.equals(NotationType.CHEN) ||
					notation.equals(NotationType.CROWSFOOT)
				) {
					checkCardinality(relation)
				}
			}
		}
	}
	
	def checkCardinality(RelationEntity relation) {
		switch relation.cardinality {
    		case CardinalityType.ZERO_OR_ONE,
    		case CardinalityType.ZERO_OR_MORE,
    		case CardinalityType.ONE,
    		case CardinalityType.MANY: return
    		default: warning(
    			'''Invalid cardinality for '«relation.target.name»'!«'\n\n'»Use [0..1], [0..N], [1] or [N]''',
    			relation,
    			RELATION_ENTITY__CARDINALITY,
    			INVALID_CARDINALITY
    		)
    	}
	}
	
	@Check
	def checkAggregation(Relationship relationship) {
		val model = relationship.eContainer
		if (model instanceof Model) {
			val notation = model.notation?.notationType
			if(notation === null){
				return
			}
			if (notation !== null) {
				if(notation.equals(NotationType.UML)){
					if(!relationship.firstType.equals(RelationshipType.DEFAULT) &&
					   !relationship.secondType.equals(RelationshipType.DEFAULT)){
						warning('''Aggregation only supported for UML''', relationship, RELATIONSHIP__SECOND_TYPE)
					}
				}else{
					if(!relationship.firstType.equals(RelationshipType.DEFAULT)){
						warning('''Aggregation only supported for UML''', relationship, RELATIONSHIP__FIRST_TYPE)
					}
					if(!relationship.secondType.equals(RelationshipType.DEFAULT)){
						warning('''Aggregation only supported for UML''', relationship, RELATIONSHIP__SECOND_TYPE)
					}
				}
			}
		}
	}
	
	@Check
	def checkVisibility(Attribute attribute) {
		val model = attribute.eContainer.eContainer
		if (model instanceof Model) {
			val notation = model.notation?.notationType
			if(notation !== null && !notation.equals(NotationType.UML) && !attribute.visibility.equals(VisibilityType.NONE)){
				warning('''Use visibility operators only for UML''', attribute, ATTRIBUTE__VISIBILITY)
		
			}
		}
	}
}
